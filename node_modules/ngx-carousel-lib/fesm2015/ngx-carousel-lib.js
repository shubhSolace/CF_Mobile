import { Directive, HostListener, ElementRef, Renderer2, Output, EventEmitter, Component, Input, ViewChild, NgModule } from '@angular/core';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * :tmtfactory) Â© 2017
 * Alex Marcos <alejandro.marcos@tmtfactory.com>
 * @ignore
 */
class Carousel {
    constructor() {
        this._currdeg = 0;
        this._totalItems = 0;
        this._maxWidthSize = 0;
        this._maxHeightSize = 0;
        this._maxDegree = 0;
        this._totalWidth = 0;
        this._isHorizontal = false;
        this._items = [];
        this._degreesSlides = [];
        this._activeIndex = 0;
        this._lastIndex = -1;
        this._lockSlides = false;
        this._autoPlayIsRunning = false;
    }
    /**
     * @return {?}
     */
    get autoPlayIsRunning() {
        return this._autoPlayIsRunning;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set autoPlayIsRunning(value) {
        this._autoPlayIsRunning = value;
    }
    /**
     * @return {?}
     */
    get currdeg() {
        return this._currdeg;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set currdeg(value) {
        this._currdeg = value;
    }
    /**
     * @return {?}
     */
    get totalItems() {
        return this._totalItems;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set totalItems(value) {
        this._totalItems = value;
    }
    /**
     * @return {?}
     */
    get isHorizontal() {
        return this._isHorizontal;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set isHorizontal(value) {
        this._isHorizontal = value;
    }
    /**
     * @return {?}
     */
    get maxWidthSize() {
        return this._maxWidthSize;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set maxWidthSize(value) {
        this._maxWidthSize = value;
    }
    /**
     * @return {?}
     */
    get maxHeightSize() {
        return this._maxHeightSize;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set maxHeightSize(value) {
        this._maxHeightSize = value;
    }
    /**
     * @return {?}
     */
    get maxDegree() {
        return this._maxDegree;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set maxDegree(value) {
        this._maxDegree = value;
    }
    /**
     * @return {?}
     */
    get totalWidth() {
        return this._totalWidth;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set totalWidth(value) {
        this._totalWidth = value;
    }
    /**
     * @return {?}
     */
    get items() {
        return this._items;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set items(value) {
        this._items = value;
    }
    /**
     * @return {?}
     */
    get degreesSlides() {
        return this._degreesSlides;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set degreesSlides(value) {
        this._degreesSlides = value;
    }
    /**
     * @return {?}
     */
    get activeIndex() {
        return this._activeIndex;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set activeIndex(value) {
        this._activeIndex = value;
    }
    /**
     * @return {?}
     */
    get lockSlides() {
        return this._lockSlides;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set lockSlides(value) {
        this._lockSlides = value;
    }
    /**
     * @return {?}
     */
    get lastIndex() {
        return this._lastIndex;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set lastIndex(value) {
        this._lastIndex = value;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const ZERO = 0.000000000001;
/** @type {?} */
const DIRECTION = {
    LEFT: 'left',
    RIGHT: 'right',
    UP: 'up',
    DOWN: 'down',
    NONE: 'none',
};
class SwiperDirective {
    /**
     * @param {?} el
     * @param {?} renderer
     */
    constructor(el, renderer) {
        this.el = el;
        this.renderer = renderer;
        this.isDown = false;
        this.initialPosX = ZERO;
        this.initialPosY = ZERO;
        this.lastPosX = ZERO;
        this.lastPosY = ZERO;
        this.swipeDistanceX = ZERO;
        this.swipeDistanceY = ZERO;
        this.firstSwipeDate = Date.now();
        this.direction = DIRECTION.NONE;
        this.onSwipeRight = new EventEmitter();
        this.onSwipeLeft = new EventEmitter();
        this.onSwipeUp = new EventEmitter();
        this.onSwipeDown = new EventEmitter();
        this.onSwipe = new EventEmitter();
        this.onSwipeStart = new EventEmitter();
        this.onSwipeEnd = new EventEmitter();
        this.swipeLeft = new EventEmitter();
        this.swipeRight = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * @param {?} event
     * @return {?}
     */
    getResultFromEvent(event) {
        /** @type {?} */
        let swipeFrameDistanceX = event.clientX - this.initialPosX - this.lastPosX;
        swipeFrameDistanceX = swipeFrameDistanceX < 30 ? swipeFrameDistanceX : 30;
        this.swipeDistanceX += swipeFrameDistanceX;
        /** @type {?} */
        let swipeFrameDistanceY = event.clientY - this.initialPosY - this.lastPosY;
        swipeFrameDistanceY = swipeFrameDistanceY < 30 ? swipeFrameDistanceY : 30;
        this.swipeDistanceY += swipeFrameDistanceY;
        this.lastPosX = event.clientX - this.initialPosX;
        this.lastPosY = event.clientY - this.initialPosY;
        /** @type {?} */
        const res = {
            velocityX: swipeFrameDistanceX,
            velocityY: swipeFrameDistanceY,
            isFinal: false,
            direction: this.direction,
            event: event,
        };
        return res;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    swipeStart(event) {
        this.firstSwipeDate = Date.now();
        this.isDown = true;
        this.initialPosX = event.clientX;
        this.initialPosY = event.clientY;
        this.swipeDistanceX = ZERO;
        this.swipeDistanceY = ZERO;
        this.onSwipeStart.emit();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    swipeEnd(event) {
        this.initialPosX = this.lastPosX = ZERO;
        this.initialPosY = this.lastPosY = ZERO;
        this.isDown = false;
        /** @type {?} */
        const res = {
            velocityX: 0,
            velocityY: 0,
            isFinal: !this.isDown,
        };
        this.onSwipeEnd.emit(res);
        this.swipeDistanceX = ZERO;
        this.swipeDistanceY = ZERO;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    swipeMove(event) {
        /** @type {?} */
        const res = this.getResultFromEvent(event);
        if (res.velocityX > 0) {
            this.direction = DIRECTION.LEFT;
            this.onSwipeLeft.emit(res);
        }
        else if (res.velocityX < 0) {
            this.direction = DIRECTION.RIGHT;
            this.onSwipeRight.emit(res);
        }
        else if (res.velocityY > 0) {
            this.direction = DIRECTION.DOWN;
            this.onSwipeDown.emit(res);
        }
        else if (res.velocityY < 0) {
            this.direction = DIRECTION.UP;
            this.onSwipeUp.emit(res);
        }
        this.onSwipe.emit(res);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onTouchStart(event) {
        /** @type {?} */
        const touch = event.touches[0] || event.changedTouches[0];
        this.swipeStart(touch);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onMouseDown(event) {
        this.swipeStart(event);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onMouseUp(event) {
        this.swipeEnd(event);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onTouchEnd(event) {
        /** @type {?} */
        const touch = event.touches[0] || event.changedTouches[0];
        this.swipeEnd(touch);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onMouseMove(event) {
        if (this.isDown) {
            this.swipeMove(event);
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onTouchMove(event) {
        /** @type {?} */
        const touch = event.touches[0] || event.changedTouches[0];
        this.swipeMove(touch);
    }
}
SwiperDirective.decorators = [
    { type: Directive, args: [{
                selector: '[swiper]',
                exportAs: 'swiper'
            },] }
];
/** @nocollapse */
SwiperDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
SwiperDirective.propDecorators = {
    onSwipeRight: [{ type: Output }],
    onSwipeLeft: [{ type: Output }],
    onSwipeUp: [{ type: Output }],
    onSwipeDown: [{ type: Output }],
    onSwipe: [{ type: Output }],
    onSwipeStart: [{ type: Output }],
    onSwipeEnd: [{ type: Output }],
    swipeLeft: [{ type: Output }],
    swipeRight: [{ type: Output }],
    onTouchStart: [{ type: HostListener, args: ['touchstart', ['$event'],] }],
    onMouseDown: [{ type: HostListener, args: ['mousedown', ['$event'],] }],
    onMouseUp: [{ type: HostListener, args: ['document:mouseup', ['$event'],] }],
    onTouchEnd: [{ type: HostListener, args: ['touchend', ['$event'],] }],
    onMouseMove: [{ type: HostListener, args: ['mousemove', ['$event'],] }],
    onTouchMove: [{ type: HostListener, args: ['touchmove', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CarouselComponent {
    /**
     * @param {?} componentElement
     */
    constructor(componentElement) {
        this.componentElement = componentElement;
        this.itemsCarouselRendered = 0;
        this.morePairSlides = 1;
        this.threshold = 5;
        this.angle = 45;
        this.ratioScale = 1;
        this.margin = 20;
        this.perspective = 2000;
        this.endInSlide = true;
        this.timeToSlide = 300;
        this.lockSlides = false;
        this.initialSlide = 0;
        this.loop = false;
        this.mode = 'horizontal';
        // autoPlay
        this.autoPlay = false;
        this.delayAutoPlay = 3000;
        this.onInit = new EventEmitter();
        this.onReady = new EventEmitter();
        this.onChangeProperties = new EventEmitter();
        this.onSlideChange = new EventEmitter();
        this.onSlideCentered = new EventEmitter();
        this.onTransitionStart = new EventEmitter();
        this.onTransitionEnd = new EventEmitter();
        this.onSlideNextTransitionStart = new EventEmitter();
        this.onSlideNextTransitionEnd = new EventEmitter();
        this.onSlidePrevTransitionStart = new EventEmitter();
        this.onSlidePrevTransitionEnd = new EventEmitter();
        this.onSlideMove = new EventEmitter();
        this.onSlideMoveEnd = new EventEmitter();
        this.onSlideMoveStart = new EventEmitter();
        this.onTouchMove = new EventEmitter();
        this.onTouchStart = new EventEmitter();
        this.onTouchEnd = new EventEmitter();
        this.onReachBeginning = new EventEmitter();
        this.onReachEnd = new EventEmitter();
        this.carousel = new Carousel();
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    onDomChange($event) {
        if ($event.addedNodes.length > 0) {
            if (this.itemsCarouselRendered === 0) {
                this.reInit();
            }
            else {
                this.update();
                this.updateCssShowSlides();
            }
            this.itemsCarouselRendered = this.carouselElm.nativeElement.getElementsByClassName('item-carousel').length;
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.onInit.emit(this.carousel);
        this.itemsCarouselRendered = this.carouselElm.nativeElement.getElementsByClassName('item-carousel').length;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        Object.keys(changes).map((/**
         * @param {?} val
         * @return {?}
         */
        val => {
            if (changes[val].currentValue !== changes[val].previousValue && !changes[val].isFirstChange()) {
                this.update();
                this.onChangeProperties.emit(changes);
            }
        }));
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.initEventsPan();
        this.configPlugin();
        setTimeout((/**
         * @return {?}
         */
        function () {
            this.componentElement.nativeElement.className += ' ready';
        }).bind(this));
        this.onReady.emit(this.carousel);
    }
    /**
     * @param {?} val
     * @return {?}
     */
    lockCarousel(val) {
        this.carousel.lockSlides = val;
    }
    /**
     * @return {?}
     */
    slideNext() {
        if (this.checkLimitsCarrousel(this.carousel.activeIndex + 1)) {
            this.moveSlideTo(this.carousel.activeIndex + 1);
            /** @type {?} */
            const vm = this;
            setTimeout((/**
             * @return {?}
             */
            () => vm.detectCurrentSlide()));
        }
    }
    /**
     * @return {?}
     */
    slidePrev() {
        if (this.checkLimitsCarrousel(this.carousel.activeIndex - 1)) {
            this.moveSlideTo(this.carousel.activeIndex - 1);
            /** @type {?} */
            const vm = this;
            setTimeout((/**
             * @return {?}
             */
            () => vm.detectCurrentSlide()));
        }
    }
    /**
     * @param {?} index
     * @return {?}
     */
    slideTo(index) {
        if (this.checkLimitsCarrousel(index)) {
            this.moveSlideTo(index);
            /** @type {?} */
            const vm = this;
            setTimeout((/**
             * @return {?}
             */
            () => vm.detectCurrentSlide()));
        }
    }
    /**
     * @return {?}
     */
    autoPlayStart() {
        this.autoPlay = true;
        this.autoPlaySlide();
    }
    /**
     * @return {?}
     */
    autoPlayStop() {
        clearInterval(this.autoPlayTimeout);
        this.carousel.autoPlayIsRunning = false;
    }
    /**
     * @return {?}
     */
    toggleMode() {
        this.mode = this.mode === 'vertical' ? 'horizontal' : 'vertical';
        this.update();
    }
    /**
     * @return {?}
     */
    reInit() {
        this.carousel = new Carousel;
        this.configPlugin();
    }
    /**
     * @return {?}
     */
    update() {
        this.setPerspectiveContainer();
        this.checkRotation();
        this.carousel.items = Array.from(this.carouselElm.nativeElement.getElementsByClassName('item-carousel'));
        this.carousel.totalItems = this.carousel.items.length;
        this.getmaxSizes();
        this.carousel.lockSlides = this.lockSlides;
        this.setDegreesOnSlides();
        this.setTransformCarrousel(-this.carousel.degreesSlides[this.carousel.activeIndex]);
    }
    /**
     * @private
     * @return {?}
     */
    configPlugin() {
        this.update();
        this.manageEvents();
        this.initSlidesOn();
        this.updateCssShowSlides();
        this.autoPlaySlide();
    }
    /**
     * @private
     * @return {?}
     */
    initEventsPan() {
        this.swiper.onSwipe.subscribe((/**
         * @param {?} distance
         * @return {?}
         */
        (distance) => {
            this.rotate(distance);
        }));
        this.swiper.onSwipeEnd.subscribe((/**
         * @param {?} distance
         * @return {?}
         */
        (distance) => {
            this.rotate(distance);
        }));
    }
    /**
     * @private
     * @param {?} e
     * @return {?}
     */
    rotate(e) {
        if (!this.carousel.lockSlides) {
            /** @type {?} */
            const velocity = this.carousel.isHorizontal ? e.velocityX / this.threshold : -e.velocityY / this.threshold;
            this.setNewDeg(this.carousel.currdeg + velocity * window.devicePixelRatio);
            this.moveCarrousel(this.carousel.currdeg);
            if (e.isFinal && this.endInSlide) {
                this.moveSlideTo(this.carousel.activeIndex);
            }
        }
    }
    /**
     * @private
     * @return {?}
     */
    autoPlaySlide() {
        if (this.autoPlay) {
            this.autoPlayTimeout = setTimeout((/**
             * @return {?}
             */
            function () {
                this.carousel.autoPlayIsRunning = true;
                this.slideNext();
                this.autoPlaySlide();
            }).bind(this), this.delayAutoPlay);
        }
    }
    /**
     * @private
     * @return {?}
     */
    initSlidesOn() {
        if (this.initialSlide >= 0 && this.initialSlide < this.carousel.items.length) {
            this.carousel.activeIndex = parseInt(this.initialSlide.toString());
        }
        else if (this.initialSlide >= this.carousel.items.length) {
            this.carousel.activeIndex = this.carousel.items.length - 1;
            this.initialSlide = this.carousel.activeIndex;
        }
        else {
            this.carousel.activeIndex = 0;
            this.initialSlide = this.carousel.activeIndex;
        }
        /** @type {?} */
        const newDeg = this.carousel.activeIndex * this.angle;
        this.setNewDeg(-newDeg);
        this.setTransformCarrousel(-newDeg);
    }
    /**
     * @private
     * @param {?} newDeg
     * @return {?}
     */
    setNewDeg(newDeg) {
        this.carousel.currdeg = newDeg;
        if (this.carousel.currdeg > 0) {
            this.carousel.currdeg = 0;
        }
        if (this.carousel.currdeg < -this.carousel.maxDegree) {
            this.carousel.currdeg = -this.carousel.maxDegree;
        }
    }
    /**
     * @private
     * @return {?}
     */
    checkRotation() {
        this.carousel.isHorizontal = this.mode !== 'vertical';
        this.rotationFn = this.carousel.isHorizontal ? 'rotateY'
            : 'rotateX';
    }
    /**
     * @private
     * @param {?} index
     * @return {?}
     */
    checkLimitsCarrousel(index) {
        return this.carousel.activeIndex !== index && index >= 0 && index < this.carousel.totalItems;
    }
    /**
     * @private
     * @param {?} index
     * @return {?}
     */
    moveSlideTo(index) {
        this.setNewDeg(-this.carousel.degreesSlides[index]);
        this.moveCarrousel(this.carousel.currdeg, this.timeToSlide);
    }
    /**
     * @private
     * @param {?} deg
     * @param {?=} timeTransform
     * @return {?}
     */
    moveCarrousel(deg, timeTransform = 0) {
        /** @type {?} */
        const transition = `transform ${timeTransform}ms`;
        this.carouselElm.nativeElement.style.transition = transition;
        this.carouselElm.nativeElement.style.webkitTransition = transition;
        this.setTransformCarrousel(deg);
        this.detectCurrentSlide();
    }
    /**
     * @private
     * @param {?} deg
     * @return {?}
     */
    setTransformCarrousel(deg) {
        /** @type {?} */
        const transform = `translateZ(${-this.radius}px) ${this.rotationFn}(${deg}deg)`;
        this.carouselElm.nativeElement.style.transform = transform;
        this.carouselElm.nativeElement.style.webkitTransform = transform;
        this.sendSlideIsCentered();
    }
    /**
     * @private
     * @return {?}
     */
    sendSlideIsCentered() {
        if (this.carousel.currdeg === -this.carousel.degreesSlides[this.carousel.activeIndex]) {
            this.onSlideCentered.emit(this.carousel);
        }
    }
    /**
     * @private
     * @return {?}
     */
    setPerspectiveContainer() {
        this.containerElm.nativeElement.style.perspective = this.perspective;
        this.containerElm.nativeElement.style.webkitPerspective = this.perspective;
        this.containerElm.nativeElement.style.MozPerspective = this.perspective;
    }
    /**
     * @private
     * @return {?}
     */
    getmaxSizes() {
        this.carousel.items.map((/**
         * @param {?} val
         * @return {?}
         */
        (val) => {
            /** @type {?} */
            const width = val.offsetWidth;
            /** @type {?} */
            const height = val.offsetHeight;
            this.carousel.maxWidthSize = 0;
            this.carousel.maxHeightSize = 0;
            if (width > this.carousel.maxWidthSize) {
                this.carousel.maxWidthSize = width;
                this.carousel.totalWidth = this.carousel.items.length * this.carousel.maxWidthSize;
            }
            if (height > this.carousel.maxHeightSize) {
                this.carousel.maxHeightSize = height;
                this.carousel.totalWidth = this.carousel.items.length * this.carousel.maxHeightSize;
            }
        }));
        this.setContainerWithMaxSize();
    }
    /**
     * @private
     * @return {?}
     */
    setContainerWithMaxSize() {
        this.containerElm.nativeElement.style.width = this.carousel.maxWidthSize + 'px';
        this.containerElm.nativeElement.style.height = this.carousel.maxHeightSize + 'px';
    }
    /**
     * @private
     * @return {?}
     */
    setDegreesOnSlides() {
        /** @type {?} */
        let auxDegree = 0;
        /** @type {?} */
        const panelSize = this.carousel.isHorizontal ? this.carousel.maxWidthSize : this.carousel.maxHeightSize;
        this.radius = (Math.round((panelSize / 2) /
            Math.tan(Math.PI / (360 / this.angle))) + this.margin);
        this.carousel.degreesSlides = [];
        this.carousel.items.map((/**
         * @param {?} val
         * @param {?} index
         * @return {?}
         */
        (val, index) => {
            /** @type {?} */
            const transform = `${this.rotationFn}(${auxDegree}deg) translateZ(${this.radius}px)`;
            val.style.transform = transform;
            val.style.webkitTransform = transform;
            this.carousel.degreesSlides.push(auxDegree);
            this.carousel.maxDegree = auxDegree;
            auxDegree += this.angle;
        }));
    }
    /**
     * @private
     * @return {?}
     */
    detectCurrentSlide() {
        /** @type {?} */
        let aux = 99e9;
        /** @type {?} */
        let index = 0;
        this.carousel.degreesSlides.forEach((/**
         * @param {?} val
         * @param {?} i
         * @return {?}
         */
        (val, i) => {
            /** @type {?} */
            const res = Math.abs(val - Math.abs(this.carousel.currdeg));
            if (res < aux) {
                aux = res;
                index = i;
            }
        }));
        if (this.carousel.activeIndex !== index) {
            this.carousel.lastIndex = this.carousel.activeIndex;
            this.carousel.activeIndex = index;
            this.updateCssShowSlides();
            this.onSlideChange.emit(this.carousel);
            if (this.carousel.activeIndex === 0) {
                this.onReachBeginning.emit(this.carousel);
            }
            else if (this.carousel.activeIndex === this.carousel.totalItems - 1) {
                this.onReachEnd.emit(this.carousel);
            }
        }
    }
    /**
     * @private
     * @return {?}
     */
    updateCssShowSlides() {
        /** @type {?} */
        const vm = this;
        /** @type {?} */
        const currentIndex = vm.carousel.activeIndex;
        /** @type {?} */
        const actual = this.carousel.items[currentIndex];
        vm.removeClassShowSlides('actual');
        vm.removeClassShowSlides('prev');
        vm.removeClassShowSlides('next');
        if (actual) {
            actual.className += ' actual';
        }
        for (let x = 0; x < this.morePairSlides; x++) {
            /** @type {?} */
            const prev = vm.carousel.items[currentIndex - (x + 1)];
            /** @type {?} */
            const next = vm.carousel.items[currentIndex + (x + 1)];
            if (prev) {
                prev.className += ' prev';
            }
            if (next) {
                next.className += ' next';
            }
        }
    }
    /**
     * @private
     * @param {?} tagClass
     * @return {?}
     */
    removeClassShowSlides(tagClass) {
        if (this.carouselElm.nativeElement.getElementsByClassName(tagClass).length > 0) {
            Array.from(this.carouselElm.nativeElement.getElementsByClassName(tagClass)).map((/**
             * @param {?} val
             * @return {?}
             */
            (val) => {
                val['classList'].remove(tagClass);
            }));
        }
    }
    /**
     * @private
     * @return {?}
     */
    manageEvents() {
        /** @type {?} */
        const vm = this;
        this.swiper.onSwipe.subscribe((/**
         * @param {?} e
         * @return {?}
         */
        (e) => {
            vm.onSlideMove.emit({ carousel: vm.carousel, event: e });
            vm.onTouchMove.emit({ carousel: vm.carousel, event: e });
        }));
        this.swiper.onSwipeStart.subscribe((/**
         * @param {?} e
         * @return {?}
         */
        (e) => {
            vm.onSlideMoveStart.emit({ carousel: vm.carousel, event: e });
            vm.onTouchStart.emit({ carousel: vm.carousel, event: e });
        }));
        this.swiper.onSwipeEnd.subscribe((/**
         * @param {?} e
         * @return {?}
         */
        (e) => {
            vm.onSlideMoveEnd.emit({ carousel: vm.carousel, event: e });
            vm.onTouchEnd.emit({ carousel: vm.carousel, event: e });
        }));
        this.carouselElm.nativeElement.addEventListener('transitionend', (/**
         * @param {?} e
         * @return {?}
         */
        (e) => {
            /** @type {?} */
            const elm = { carousel: vm.carousel, event: e };
            if (e.propertyName === 'transform') {
                this.onTransitionEnd.emit(elm);
                if (vm.carousel.lastIndex > vm.carousel.activeIndex) {
                    this.onSlideNextTransitionEnd.emit(elm);
                }
                else {
                    this.onSlidePrevTransitionEnd.emit(elm);
                }
            }
        }));
        this.carouselElm.nativeElement.addEventListener('transitionstart', (/**
         * @param {?} e
         * @return {?}
         */
        (e) => {
            /** @type {?} */
            const elm = { carousel: vm.carousel, event: e };
            if (e.propertyName === 'transform') {
                this.onTransitionStart.emit(elm);
                // if (e.direction === Hammer.DIRECTION_LEFT) {
                //   vm.onSlideNextTransitionStart.emit(elm);
                // } else if (e.direction === Hammer.DIRECTION_RIGHT) {
                //   vm.onSlidePrevTransitionStart.emit(elm);
                // }
            }
        }));
        window.addEventListener('resize', (/**
         * @return {?}
         */
        function () {
            this.update();
        }).bind(this));
    }
}
CarouselComponent.decorators = [
    { type: Component, args: [{
                selector: 'carousel-component',
                template: '<div class="container" #container>\n' +
                    '  <div class="carousel" #carousel swiper (domChange)="onDomChange($event)">\n' +
                    '    <ng-content select=".item-carousel"></ng-content>\n' +
                    '  </div>\n' +
                    '</div>',
                styles: [`
   :host{
        display: flex;
    }
   :host .container {
        margin: 0 auto;
        width: 600px;
        height: 400px;
        position: relative;
    }
   :host .container .carousel {
        height: 100%;
        width: 100%;
        position: absolute;
        -webkit-transform-style: preserve-3d;
        -moz-transform-style: preserve-3d;
        -o-transform-style: preserve-3d;
        transform-style: preserve-3d;

    }
   :host.ready .carousel {
        -webkit-transition: -webkit-transform 300ms;
        -moz-transition:-moz-transform 300ms;
        -o-transition: -o-transform 300ms;
        transition: transform 300ms;
    }
   :host .container .carousel::content >>> .item-carousel {
        display: block;
        position: absolute;
        border:1px solid black;
        width: 100%;
        height: 100%;
        text-align: center;
        transform-style: preserve-3d;
        opacity: 0;
    }
   :host.ready .carousel::content >>> .item-carousel {
        -webkit-transition: opacity 300ms, -webkit-transform 300ms;
        -moz-transition: opacity 300ms, -moz-transform 300ms;
        -o-transition: opacity 300ms, -o-transform 300ms;
        transition: opacity 300ms, transform 300ms;
    }

   :host .container .carousel::content >>> .item-carousel img{
        user-drag: none;
        user-select: none;
        -moz-user-select: none;
        -webkit-user-drag: none;
        -webkit-user-select: none;
        -ms-user-select: none;
    }

   :host .container .carousel::content >>> .item-carousel.next,
   :host .container .carousel::content >>> .item-carousel.prev,
   :host .container .carousel::content >>> .item-carousel.actual{
        opacity: 0.95;
    }
  `]
            }] }
];
/** @nocollapse */
CarouselComponent.ctorParameters = () => [
    { type: ElementRef }
];
CarouselComponent.propDecorators = {
    swiper: [{ type: ViewChild, args: [SwiperDirective,] }],
    morePairSlides: [{ type: Input }],
    threshold: [{ type: Input }],
    angle: [{ type: Input }],
    ratioScale: [{ type: Input }],
    margin: [{ type: Input }],
    perspective: [{ type: Input }],
    endInSlide: [{ type: Input }],
    timeToSlide: [{ type: Input }],
    lockSlides: [{ type: Input }],
    initialSlide: [{ type: Input }],
    loop: [{ type: Input }],
    mode: [{ type: Input }],
    autoPlay: [{ type: Input }],
    delayAutoPlay: [{ type: Input }],
    onInit: [{ type: Output }],
    onReady: [{ type: Output }],
    onChangeProperties: [{ type: Output }],
    onSlideChange: [{ type: Output }],
    onSlideCentered: [{ type: Output }],
    onTransitionStart: [{ type: Output }],
    onTransitionEnd: [{ type: Output }],
    onSlideNextTransitionStart: [{ type: Output }],
    onSlideNextTransitionEnd: [{ type: Output }],
    onSlidePrevTransitionStart: [{ type: Output }],
    onSlidePrevTransitionEnd: [{ type: Output }],
    onSlideMove: [{ type: Output }],
    onSlideMoveEnd: [{ type: Output }],
    onSlideMoveStart: [{ type: Output }],
    onTouchMove: [{ type: Output }],
    onTouchStart: [{ type: Output }],
    onTouchEnd: [{ type: Output }],
    onReachBeginning: [{ type: Output }],
    onReachEnd: [{ type: Output }],
    carouselElm: [{ type: ViewChild, args: ['carousel',] }],
    containerElm: [{ type: ViewChild, args: ['container',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DomChangeDirective {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.domChange = new EventEmitter();
        /** @type {?} */
        const element = this.elementRef.nativeElement;
        this.changes = new MutationObserver((/**
         * @param {?} mutations
         * @return {?}
         */
        (mutations) => {
            mutations.forEach((/**
             * @param {?} mutation
             * @return {?}
             */
            (mutation) => this.domChange.emit(mutation)));
        }));
        this.changes.observe(element, {
            attributes: true,
            childList: true,
            characterData: true
        });
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.changes.disconnect();
    }
}
DomChangeDirective.decorators = [
    { type: Directive, args: [{
                selector: '[domChange]'
            },] }
];
/** @nocollapse */
DomChangeDirective.ctorParameters = () => [
    { type: ElementRef }
];
DomChangeDirective.propDecorators = {
    domChange: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const COMPONENTS = [
    CarouselComponent,
];
/** @type {?} */
const DIRECTIVES = [
    SwiperDirective,
    DomChangeDirective
];
class CarouselModule {
}
CarouselModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    ...COMPONENTS,
                    ...DIRECTIVES,
                ],
                imports: [],
                exports: [
                    ...COMPONENTS,
                    ...DIRECTIVES,
                ],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { CarouselComponent, CarouselModule, DomChangeDirective as Éµb, SwiperDirective as Éµa };

//# sourceMappingURL=ngx-carousel-lib.js.map